## The basic concept of the dataflow

### the main relation type in dataflow 
1. column to column dataflow, the data of target column is coming from the source column(fdd). 
2. column to resultset(mainly select list), the row number of the resultset is impacted by the source column(fdr).
3. resultset to resultset, the row number of a source table in the from clause impact the row number of the target select list.(fdr)

### analyze dataflow in the different SQL elements -  part 1
1. select list
2. where clause
3. function (case expression)
4. group by(aggregate function)
5. from clause
6. handle of select * (Not finished yet)

#### 1. select list
```sql
SELECT a.empName "eName"
FROM scott.emp a
```
the data of target column `"eName"` comes from `scott.emp.empName`, so we have a dataflow relation like this:
```
scott.emp.empName -> fdd -> "eName"
```
the result generated by the select list called: `resultset` likes a virtual table includes column and rows.

#### 2. where clause
```sql
SELECT a.empName "eName"
FROM scott.emp a
Where sal > 1000
```
The total row number of the select list is impacted by the value of column `sal` in the where clause. So we have a dataflow relation like this:
```
sal -> fdr -> resultset.pseudoRows
```

As you can see, we introduced a new pseudo column: `pseudoRows` here to represents the row number of the resultset.

#### 3. function
In the dataflow analyzing, `function` plays a key role. It accepts arguments which usually is column and generate resultset which maybe a scalar value or a set value. 
```sql
select round(salary) as sal from scott.emp
```

The relation of the `round` function in the above SQL :
```
scott.emp.salary -> fdd -> round(salary) -> fdd -> sal
```

#### 4. group by and aggregate function
```sql
SELECT deptno, COUNT() num_emp, SUM(SAL) sal_sum
FROM scott.emp
Where city = 'NYC'
GROUP BY deptno
```

##### 4.1 

since `SUM()` is an aggregate function, so `deptno` column in the group by clause will be treated as an implict argument of the `SUM()` function. However, `deptno` column doesn't directly contribute the value to the `SUM()` function as column `SAL` does, So, we have this relation:
```
scott.emp.deptno -> fdr -> SUM(SAL) -> fdd -> sal_sum
```

Columns in the having clause have the same relation as mentioned above.

##### 4.2  
The value of `SUM()` function also effected by the total rows of the table `scott.emp`, so, there is a relation like this:
```
scott.emp.pseudoRows -> fdr -> SUM(SAL) -> fdd -> sal_sum
```

The above rules apply to all aggregation functions, such as the `count()` function in the SQL.

#### 5. From clause
If the resultset of a subquery or CTE is used in the from clause of the upper-level statement, then the impact of the lower level resultset  will be transferred to the uplevel. 
```sql
WITH
  cteReports (EmpID, FirstName, LastName, MgrID, EmpLevel)
  AS
  (
    SELECT EmployeeID, FirstName, LastName, ManagerID, 1  -- resultset1
    FROM Employees
    WHERE ManagerID IS NULL
  )
SELECT
  FirstName + ' ' + LastName AS FullName, EmpLevel  -- resultset2
FROM cteReports 
```

In the CTE, there is an impact relation:
```
Employees.ManagerID -> fdr -> resultset1.pseudoRows
```
Since `cteReports` is used in the from clause of the upper-level statement, then the impact will carry on like this:
```
Employees.ManagerID -> fdr -> resultset1.pseudoRows -> fdd -> resultset2.pseudoRows
```

If we choose to ignore the intermediate resultset, the end to end dataflow is :
```
Employees.ManagerID -> fdr -> resultset2.pseudoRows
```


### handle the dataflow chain
every relation in the SQL is picked up by the tool, and connected together to show the whole dataflow chain. Sometimes, we need to see only the end to end relation and ignore all the intermediate relation.

If we need to convert a fully chained dataflow to an `end to end ` dataflow, we may consider the following rules:

1. A single dataflow chain with mixed relation type: fdd and fdr. 
    ```
    A -> fdd -> B -> fdr -> C -> fdd -> D
    ```
    the rule is: if any `fdr` relation appears in the chain, the relation from `A -> D` will be consider as type of `fdr`, otherwise, the final relation is `fdd` for the end to end relation of `A -> D`.

2. If there are multiple chains from  `A -> D`
    ```
    A -> fdd -> B1 -> fdr -> C1 -> fdd -> D
    A -> fdd -> B2 -> fdr -> C1 -> fdd -> D
    A -> fdd -> B3 -> fdd -> C3 -> fdd -> D
    ```
    The final relation should choose the `fdd` chain if any.

### analyze dataflow in the different SQL elements -  part 2
#### 1. case expression

```sql
 select
 	case when a.kamut=1 and b.teur IS null
 			 then 'no locks'
 		 when a.kamut=1
 			then b.teur
 	else 'locks'
 	end teur
 from tbl a left join TT b on (a.key=b.key)
```
During the analyzing of dataflow, case expression is treated as a function. The column used inside the case expression will be analyzed like the arguments of a function. So for the above SQL, the following relation is discovered:
```
tbl.kamut -> fdd -> teur
TT.teur -> fdd -> teur
```

#### 2. join condition

Columns in the join condition also effect the row number of resultset of the select list just like column in the where clause do. So, the following relation will be discoverd in the above SQL.
```
tbl.key -> fdr -> resultset.PseudoRows
TT.key -> fdr -> resultset.PseudoRows
```

#### 3. create view
```sql
create view vEmp(eName) as
SELECT a.empName "eName"
FROM scott.emp a
Where sal > 1000
```
From this query, you will see how the column `sal` in where clause impact the number of rows in the view `vEmp`.
```
scott.emp.sal -> fdr -> resultset1.PseudoRows -> fdr -> vEmp.PseudoRows
```

So, from an end to end point of view, there will be a `fdr` relation between column `sal` and view `vEmp` like this:
```
scott.emp.sal -> fdr -> vEmp.PseudoRows
```

#### 4. rename/swap table
```sql
alter table t2 rename to t3;
```
We also use `PseudoRows` to represent the relation when rename table, the relation type is `fdd`.
```
t2.PseudoRows -> fdd -> t3.PseudoRows
```

### The meaning of the letter in fdd, fdr

The meaning of the letter in fdd, fdr. f: dataflow, d: data value, r: record set.

The first letter is always f，the second letter represents the source column，the third letter represents the target column, the fourth is reserved.

* fdd: data of the source column will used in the target column
* fdr: data of the source column will impact the number of the resultset in the select list, or will impact the result value of an anggreate function.

